## h17_ane_fw_theia_d9x.im4p

> `h17_ane_fw_theia_d9x.im4p`

```diff

 
-  __TEXT.__text: 0x8e748
-  __TEXT.__data_copy: 0x8000
-  __TEXT.__const: 0x4348
-  __TEXT.__cstring: 0x12c40
-  __TEXT._rtk_mtab: 0x2a0
+  __TEXT.__text: 0xb8840
+  __TEXT.__const: 0x421c
+  __TEXT.__cstring: 0x1ace5
   __TEXT.ce_env: 0x4000
   __TEXT.__constructor: 0x0
-  __TEXT.__chain_starts: 0x0
-  __TEXT.text_env: 0x28
-  __DATA.__const: 0x9b98
+  __TEXT.text_env: 0x20
+  __DATA.__const: 0x9bd8
   __DATA._rtk_heap: 0x1000
-  __DATA.__data: 0xd60
-  __DATA._rtk_power: 0x368
-  __DATA._rtk_patchbay: 0x238
+  __DATA.__data: 0xf70
+  __DATA._rtk_power: 0x3b8
+  __DATA._rtk_patchbay: 0x258
   __DATA._rtk_init_stack: 0x10000
   __DATA._rtk_irq_stack: 0x1000
   __DATA._rtk_exc_stack: 0x1000
   __DATA._rtk_tunables: 0x6a0
-  __DATA._rtk_boot: 0x8000
+  __DATA._rtk_boot: 0xc000
   __DATA._rtk_page_tables: 0x80000
   __DATA._rtk_threads: 0x0
   __DATA._fwinfo: 0x100
+  __DATA.__data_copy: 0x8000
   __DATA.__sysvars: 0x4
   __DATA._rtk_boot_l1: 0x80
+  __DATA.__chain_starts: 0x28
+  __DATA._rtk_mtab: 0x2a0
+  __DATA.__gxf_data: 0x10
   __DATA.__mod_init_func: 0x0
-  __DATA.__zerofill: 0x55928
-  Functions: 0
+  __DATA.__zerofill: 0x55978
+  Functions: 1466
   Symbols:   0
-  CStrings:  2147
+  CStrings:  3287
 
CStrings:
+ "\tFW Latency Signposts 0x%!x(MISSING) id 0x%!x(MISSING) ts %!l(MISSING)ld"
+ "\x1b[31m\"    Found Matched Priority Q[%!d(MISSING)]S[%!d(MISSING)] during Termination\"\x1b[39m"
+ "\x1b[31m\"Fail\"\x1b[39m"
+ "\x1b[31m\"[ABORT] Suspend other TQs for TQ[%!d(MISSING)]S[%!d(MISSING)] at %!l(MISSING)ld\"\x1b[39m"
+ "\x1b[31m\"[ABORT] TQ abort Q[%!d(MISSING)] -> 1 slot at %!l(MISSING)ld\"\x1b[39m"
+ "\x1b[31m\"[ABORT] TQ abort Q[%!d(MISSING)] -> both slots, first slot is %!d(MISSING) at %!l(MISSING)ld\"\x1b[39m"
+ "\x1b[31m\"[StopTqInt] nid %!d(MISSING)\"\x1b[39m"
+ "\x1b[31m[VERIFICATION]\x1b[39m BAR[%!d(MISSING)] bufferIndex %!d(MISSING) is NOT matched with any buffer!"
+ "\x1b[31m[VERIFICATION]\x1b[39m BAR[%!d(MISSING)] bufferIndex %!d(MISSING) is matched with buffers more than one!"
+ "\x1b[31m[VERIFICATION]\x1b[39m BAR[%!d(MISSING)] index %!d(MISSING) should <= %!d(MISSING)!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Generic ANE[%!d(MISSING)] nbrOfNe %!d(MISSING) exceeds H11 max NE %!d(MISSING)!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Generic section (%!l(MISSING)u) is smaller than actual (%!l(MISSING)u)!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Generic section buffer[%!d(MISSING)] is not valid!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Generic section buffer[%!d(MISSING)] is wrong type %!d(MISSING)!"
+ "\x1b[31m[VERIFICATION]\x1b[39m KernelProp[%!d(MISSING)] exceeds limit (offset, len) (0x%!l(MISSING)lx, %!l(MISSING)ld) section size %!l(MISSING)u!"
+ "\x1b[31m[VERIFICATION]\x1b[39m KernelProp[%!d(MISSING)] offset 0x%!l(MISSING)lx is overlapped with the previous offset 0x%!l(MISSING)lx len %!l(MISSING)ld!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Operation BAR setup number %!d(MISSING) is exceed MAX_BAR_SLOTS %!d(MISSING)!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Operation number %!d(MISSING) exceeds MAX Operation number (%!d(MISSING))!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Operation section (%!l(MISSING)u) is smaller than actual (%!l(MISSING)u)!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Operation[%!d(MISSING)] BAR setup is wrong!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Operation[%!d(MISSING)] bar[%!d(MISSING)] index %!d(MISSING) exceeds H11 bar slots %!d(MISSING)!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Operation[%!d(MISSING)] nbrOfLocalbarSetup %!d(MISSING) exceeds EAnsProgramBarMaxIndex %!d(MISSING)!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Operation[%!d(MISSING)] nbrOfNe %!d(MISSING) exceeds H11 max NE %!d(MISSING)!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Operation[%!d(MISSING)] wrong opType %!d(MISSING)!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Procedure[%!d(MISSING)] exceeds limit (offset, len) (0x%!l(MISSING)lx, %!l(MISSING)ld) section size %!l(MISSING)u!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Procedure[%!d(MISSING)] offset 0x%!l(MISSING)lx is overlapped with the previous offset 0x%!l(MISSING)lx len %!l(MISSING)ld!"
+ "\x1b[31m[VERIFICATION]\x1b[39m SegmentProp section (%!l(MISSING)u) is smaller than actual (%!l(MISSING)u)!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Segment[%!d(MISSING)] Addr %!p(MISSING) EON %!d(MISSING) last TID %!d(MISSING) with Liveouts 0x%!x(MISSING)"
+ "\x1b[31m[VERIFICATION]\x1b[39m Segment[%!d(MISSING)] Addr %!p(MISSING) TID %!d(MISSING) with 0 size"
+ "\x1b[31m[VERIFICATION]\x1b[39m Segment[%!d(MISSING)] exceeds limit (offset, len) (0x%!l(MISSING)lx, %!l(MISSING)ld) section size %!l(MISSING)u!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Segment[%!d(MISSING)] len %!l(MISSING)ld is smaller than ane_Network_Seg_Hdr_t (BranchEn %!d(MISSING))!"
+ "\x1b[31m[VERIFICATION]\x1b[39m Segment[%!d(MISSING)] number of TD (%!d(MISSING)) does not match value in prop (%!d(MISSING))"
+ "\x1b[31m[VERIFICATION]\x1b[39m TD[%!d(MISSING)] offset 0x%!l(MISSING)lx is overlapped with the previous offset 0x%!l(MISSING)lx len %!l(MISSING)ld!"
+ "\x1b[31m[VERIFICATION]\x1b[39m maxAneUsed %!d(MISSING) :: H11 maxAneUsed should be %!d(MISSING)!"
+ "\x1b[31m[VERIFICATION]\x1b[39m sCSneCmdProcedureCall buffer[%!d(MISSING)] is not valid!"
+ "\x1b[31m[VERIFICATION]\x1b[39m sCSneCmdProcedureCall buffer[%!d(MISSING)]:index[%!d(MISSING)] SHOULD not match with Kernel!"
+ "\x1b[31m[VERIFICATION]\x1b[39m sCSneCmdProcedureCall buffer[%!d(MISSING)]:index[%!d(MISSING)] SHOULD not match with segment!"
+ "\x1b[31m[VERIFICATION]\x1b[39m sCSneCmdProcedureCall buffer[%!d(MISSING)]:index[%!d(MISSING)] is matched more than one!"
+ "\x1b[31m[VERIFICATION]\x1b[39m sCSneCmdProcedureCall buffer[%!d(MISSING)]:index[%!d(MISSING)] is not matched with any of buffers!"
+ "\x1b[31m[VERIFICATION]\x1b[39m sCSneCmdProcedureCall buffer[%!d(MISSING)]:index[%!d(MISSING)](%!l(MISSING)ld)=>Generic:buffer[%!d(MISSING)](%!l(MISSING)ld). But wrong size!"
+ "\x1b[31m[VERIFICATION]\x1b[39m sCSneCmdProcedureCall buffer[%!d(MISSING)]:index[%!d(MISSING)]=>Generic:buffer[%!d(MISSING)]. But not valid!"
+ "\x1b[31m[VERIFICATION]\x1b[39m sCSneCmdProcedureCall nbfOfbuffers %!d(MISSING) (range 1 <= # <= 64)!"
+ "\x1b[31m[VERIFICATION]\x1b[39m totalBufferNbr %!d(MISSING) :: range should 0 < # < ECSneProgramMaxBuf (%!d(MISSING))!"
+ "\x1b[32m\"Success\"\x1b[39m"
+ "\x1b[33m\"Saving KMem from 0x%!z(MISSING)x with 0x%!z(MISSING)x\"\x1b[39m"
+ "\x1b[33m\"Saving L2 from 0x%!z(MISSING)x with 0x%!z(MISSING)x\"\x1b[39m"
+ "\x1b[33m\"Saving ane registers from 0x%!z(MISSING)x with 0x%!z(MISSING)x\"\x1b[39m"
+ "\x1b[33m\"Start saving out after running into TD#%!d(MISSING) from (%!d(MISSING)-%!d(MISSING)-%!d(MISSING))\"\x1b[39m"
+ "\x1b[33m* PROGRAM :\x1b[39m"
+ "\x1b[33m* TD :\x1b[39m"
+ "\x1b[33m***** ANE RUN INFO ***** : program (0x%!x(MISSING))\x1b[39m"
+ "\x1b[33m***** ANE TD INFO ***** : program (0x%!x(MISSING))\x1b[39m"
+ "\x1b[33m************************\x1b[39m"
+ "\x1b[34m* OPTIONS *\x1b[39m"
+ "\x1b[34m***** ANE STATS *****\x1b[39m"
+ "\x1b[34m***** PROCEDURE INFO *****\x1b[39m"
+ "\x1b[34m***** PROCESS INFO *****\x1b[39m"
+ "\x1b[34m***** PROGRAM INFO *****\x1b[39m"
+ "\x1b[34m*********************\x1b[39m"
+ "\x1b[34m************************\x1b[39m"
+ "\x1b[34m**************************\x1b[39m"
+ " "
+ "          Bar[%!d(MISSING)] : barIndex %!d(MISSING) bufIndex %!d(MISSING)"
+ "     [%!d(MISSING)] : Offset %!l(MISSING)ld length %!l(MISSING)ld"
+ "     [%!d(MISSING)] : Type %!d(MISSING) nbrNe %!d(MISSING) nbrOfLocalbarSetup %!d(MISSING)"
+ "     [%!d(MISSING)] : Type %!d(MISSING) startAddr 0x%!x(MISSING) endAddr 0x%!x(MISSING) Size %!x(MISSING) nbrNe %!d(MISSING) nbrOfLocalbarSetup %!d(MISSING)"
+ "     [%!d(MISSING)] : format %!d(MISSING) isCompressed 0x%!x(MISSING) len 0x%!l(MISSING)lx offset %!l(MISSING)lx"
+ "     aneMapping[%!d(MISSING)] : %!d(MISSING)"
+ "     nBuf %!d(MISSING) inputEvent %!d(MISSING) priority %!d(MISSING) uuid 0x%!l(MISSING)lx"
+ "   %!u(MISSING) : [P:%!d(MISSING), %!s(MISSING)] -- [T:%!d(MISSING), %!s(MISSING)] -> ERROR: %!s(MISSING)\n"
+ "   %!u(MISSING) : [P:%!d(MISSING), %!s(MISSING)] -- [T:%!d(MISSING), %!s(MISSING)] -> [S:%!d(MISSING), %!s(MISSING)]\n"
+ "   %!u(MISSING) : [P:%!d(MISSING), %!s(MISSING)] -- [T:%!d(MISSING)] -> ERROR: WRONG EVENT\n"
+ "  %!s(MISSING) : There no state transitions\n"
+ "  %!s(MISSING) [%!p(MISSING)]: Last %!z(MISSING)u transitions [total = %!z(MISSING)u]:\n"
+ "  Arch: arm64e\n"
+ " %!d(MISSING) : handle 0x%!x(MISSING) offset 0x%!l(MISSING)x len 0x%!l(MISSING)x with Remap count %!d(MISSING)\n"
+ " %!d(MISSING) : handle 0x%!x(MISSING) offset 0x%!l(MISSING)x len 0x%!l(MISSING)x with map count %!d(MISSING)\n"
+ " %!d(MISSING) [%!x(MISSING)]"
+ " %!p(MISSING)"
+ " %!s(MISSING): event (%!d(MISSING), %!s(MISSING))"
+ " %!s(MISSING): event (%!d(MISSING), %!s(MISSING)), rc = %!d(MISSING) [%!x(MISSING)]"
+ " %!s(MISSING): event=%!d(MISSING) [%!s(MISSING)] cb %!s(MISSING)"
+ " Acquired %!p(MISSING)"
+ " Acquiring %!p(MISSING)"
+ " Released %!p(MISSING)"
+ " To release %!p(MISSING)"
+ "!(pageWiringOn && forceWiring)"
+ "!bSubNetworkCustomExecuteOrder"
+ "!commandBufPhysAddr"
+ "!endPointCb[pCmd->endPointId].shareMem.item[i].used"
+ "!pEntry->child"
+ "!reader"
+ "%!s(MISSING) %!f(MISSING) %!l(MISSING)ld %!l(MISSING)ld %!l(MISSING)ld\n"
+ "%!s(MISSING) %!s(MISSING) %!s(MISSING) %!s(MISSING) %!s(MISSING)\n"
+ "%!s(MISSING) %!s(MISSING) %!f(MISSING) %!f(MISSING)\n"
+ "%!s(MISSING) %!s(MISSING) %!f(MISSING) %!s(MISSING) %!f(MISSING) %!l(MISSING)ld %!l(MISSING)ld %!l(MISSING)ld\n"
+ "%!s(MISSING) %!s(MISSING) %!s(MISSING) %!f(MISSING) %!f(MISSING) %!l(MISSING)ld %!l(MISSING)ld %!l(MISSING)ld\n"
+ "%!s(MISSING) %!s(MISSING) %!s(MISSING) %!s(MISSING) %!f(MISSING) %!l(MISSING)ld %!l(MISSING)ld %!l(MISSING)ld\n"
+ "%!s(MISSING) %!s(MISSING) %!s(MISSING) %!s(MISSING) %!s(MISSING) %!s(MISSING) %!s(MISSING) %!s(MISSING)\n"
+ "%!d(MISSING) : buf %!p(MISSING) size 0x%!l(MISSING)x index 0x%!x(MISSING)\n"
+ "%!l(MISSING)ld delay trigger, %!l(MISSING)ld ignored due to exceeded execTimestamp"
+ "%!s(MISSING) : *** ACK: Endpoint command %!d(MISSING) with ticket %!u(MISSING) seq %!u(MISSING)\n"
+ "%!s(MISSING) : *** endPoint %!d(MISSING) cmd %!d(MISSING) ack 0x%!x(MISSING) ack_rc 0x%!x(MISSING) ticket %!u(MISSING) seq %!u(MISSING)\n"
+ "%!s(MISSING) : Configure pCmd endPointId = %!d(MISSING)\n"
+ "%!s(MISSING) : Free Shared Memory endPointId = %!d(MISSING) at %!p(MISSING)\n"
+ "%!s(MISSING) : Get EndPoint Status %!d(MISSING)\n"
+ "%!s(MISSING) : Get Outstanding Ticket Cnt %!d(MISSING)\n"
+ "%!s(MISSING) : Malloc Shared Memory endPointId = %!d(MISSING)\n"
+ "%!s(MISSING) : SAP Register endPointId = %!d(MISSING) sapId = 0x%!x(MISSING)\n"
+ "%!s(MISSING) : SAP UnRegister endPointId = %!d(MISSING) sapId = 0x%!x(MISSING)\n"
+ "%!s(MISSING) : Send Buf endPointId %!d(MISSING) sapId 0x%!x(MISSING) %!d(MISSING)\n"
+ "%!s(MISSING) : Unset pCmd endPointId = %!d(MISSING)\n"
+ "%!s(MISSING) : valid %!d(MISSING) bufIndex %!d(MISSING) type %!d(MISSING) addr 0x%!l(MISSING)lx memType %!d(MISSING) size %!l(MISSING)ld tag %!l(MISSING)lx"
+ "%!s(MISSING): (%!d(MISSING), %!s(MISSING)): [%!d(MISSING), %!s(MISSING)]->[%!d(MISSING), %!s(MISSING)]"
+ "%!s(MISSING): CH = %!z(MISSING)u START"
+ "%!s(MISSING): CH = %!z(MISSING)u STOP"
+ "%!s(MISSING): GOING TO STOP"
+ "%!s(MISSING): SETUP"
+ "%!s(MISSING): START"
+ "%!s(MISSING): STOP"
+ "%!s(MISSING): TEARDOWN"
+ "(%!s(MISSING)) %!s(MISSING)\n"
+ "(((size_t)(blockArray[dBlock])) %!a(MISSING)lignment[dBlock]) == 0"
+ "((size_t)pointer) < ((size_t)(h->pMsg)) + h->queueDepth * sizeof(struct ffwInterProcMsg)"
+ "((size_t)pointer) >= ((size_t)(h->pMsg))"
+ "((uintptr_t)entry->stack & (RTK_CRT_STACK_ALIGNMENT - 1)) == 0"
+ "(*parent == logDepth) || (*parent == index)"
+ "(*parent == logDepth) || (*parent == pEntry->parent)"
+ "(FFWMUTEX)0 != lock"
+ "(IOP_RINGBUFFER_VERSION == (pBuf->_header._version>>16)) || (IOP_RINGBUFFER_VERSION_V2 == (pBuf->_header._version>>16))"
+ "(SEMA)0 != cmd.syncCmdSema"
+ "(callback == NULL) || (user_signal == 0)"
+ "(ffwQueueCount (queue) == 0) || (((size_t) ffwQueueCount (queue)) == buffers)"
+ "(idx >= 0) && (idx < (mNumEntriesPerPool * mMaxPoolNum))"
+ "(idx >= 0) && (idx < hash_entries_num)"
+ "(inputs > 0) || (outputs > 0)"
+ "(mCurrPoolNum + pool_num) <= mMaxPoolNum"
+ "(new_end & HEAP_OFFSET) == 0"
+ "(operation == LOG_OPERATION_WIRED) || (operation == LOG_OPERATION_UNWIRED)"
+ "(pCmd->pBufIndex[i] & ~maskRemapIndex) < sizeof(endPointCb[pCmd->endPointId].shareMem.remap)/sizeof(endPointCb[pCmd->endPointId].shareMem.remap[0])"
+ "(pCmd->pBufIndex[i]) < sizeof(endPointCb[pCmd->endPointId].shareMem.item)/sizeof(endPointCb[pCmd->endPointId].shareMem.item[0])"
+ "(size_t) ffwQueueCount (queue) == available"
+ "(size_t)source < INTERRUPT_SRC_TOTAL"
+ "(stacksize & (RTK_CRT_STACK_ALIGNMENT - 1)) == 0"
+ "*extra_heap_size >= extra_heap_size_min"
+ "*idx < CTASKPOOL_MAXTASK_HIST_ENTRIES"
+ "*indexOut == logDepth"
+ "*outsize <= maxOutsize"
+ "*outsize >= sizeof(struct sCSneCmdPrintEnable)"
+ "*print_buffer_base != 0"
+ "*sm_base != 0"
+ "*sm_size != 0"
+ "-----------interval------------\n"
+ "./ffw64_rtxc/ffw/CBuffer.cpp"
+ "./ffw64_rtxc/ffw/CBufferPool.cpp"
+ "./ffw64_rtxc/ffw/CBufferPoolStatic.cpp"
+ "./ffw64_rtxc/ffw/CChannelManager.cpp"
+ "./ffw64_rtxc/ffw/CController.cpp"
+ "./ffw64_rtxc/ffw/CExpandablePool.cpp"
+ "./ffw64_rtxc/ffw/CFifo.cpp"
+ "./ffw64_rtxc/ffw/CFilter.cpp"
+ "./ffw64_rtxc/ffw/CGPIOManager.cpp"
+ "./ffw64_rtxc/ffw/CHashTable.cpp"
+ "./ffw64_rtxc/ffw/CIPSynchro.cpp"
+ "./ffw64_rtxc/ffw/CInterruptBuffer.cpp"
+ "./ffw64_rtxc/ffw/CLatencyProfiler.cpp"
+ "./ffw64_rtxc/ffw/CList.cpp"
+ "./ffw64_rtxc/ffw/CLoggerInterProcessor.cpp"
+ "./ffw64_rtxc/ffw/CLoggerSharedBuffer.cpp"
+ "./ffw64_rtxc/ffw/CMMU.cpp"
+ "./ffw64_rtxc/ffw/CMMULoggerPA.cpp"
+ "./ffw64_rtxc/ffw/CMMULoggerVA.cpp"
+ "./ffw64_rtxc/ffw/CMultiFilter.cpp"
+ "./ffw64_rtxc/ffw/CObject.cpp"
+ "./ffw64_rtxc/ffw/CObjectTree.cpp"
+ "./ffw64_rtxc/ffw/CPipe.cpp"
+ "./ffw64_rtxc/ffw/CPool.cpp"
+ "./ffw64_rtxc/ffw/CRoot.cpp"
+ "./ffw64_rtxc/ffw/CSharedMemory.cpp"
+ "./ffw64_rtxc/ffw/CSignalPool.cpp"
+ "./ffw64_rtxc/ffw/CTerminalOut.cpp"
+ "./ffw64_rtxc/ffw/CTimeProfiler.cpp"
+ "./ffw64_rtxc/ffw/ffwCRC.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CDebugAgent.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CEnvironment.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CISRManager.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CMailboxPool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CQueuePool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CRTOSObjectPool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CResourcePool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CScopedLock.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CSemaphorePool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CSharedMemoryHeap.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CSharedMemoryHost.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CTaskPool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CTimerManager.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CTimerPool.cpp"
+ "./ffw64_rtxc/ffw/rtkit/CTraceEventBuffer.cpp"
+ "./ffw64_rtxc/ffw/rtkit/ffwSharedMemory.cpp"
+ "./ffw64_rtxc/platform/common/CFakeChannel.cpp"
+ "./ffw64_rtxc/platform/common/CIPSynchroFake.cpp"
+ "./ffw64_rtxc/platform/common/ChannelTable.cpp"
+ "./ffw64_rtxc/platform/common/FakeChannelTable.cpp"
+ "./ffw64_rtxc/platform/theia/rtkit/CPlatformEnvironment.cpp"
+ "./ffw64_rtxc/platform/theia/rtkit/CPlatformGPIOManager.cpp"
+ "./ffw64_rtxc/platform/theia/rtkit/CPlatformISRManager.cpp"
+ "./ffw64_rtxc/platform/theia/rtkit/RealChannelTableTarget.cpp"
+ "./sne/drivers/CDeviceDriver.cpp"
+ "./sne/drivers/FE/CConfigDrvH11.cpp"
+ "./sne/ssi/src/rtxc/sema.cpp"
+ "0 < mpGroupBufCnt[group]"
+ "0 == ((size_t)virtualAddr & wiringPageMask)"
+ "0 == (physicalAddr & wiringPageMask)"
+ "0 == matched || 1 == matched"
+ "0 == mpGroupBufCnt[group]"
+ "0 == ret"
+ "0/1"
+ "1"
+ "12:42:46"
+ "<=== CMMU_LOGGER_FFW_ASSERT from %!s(MISSING)\n"
+ "===> CMMU_LOGGER_FFW_ASSERT from %!s(MISSING)\n"
+ ">>>>>>> Frame ID mismatch, expect: %!l(MISSING)ld, get: %!l(MISSING)ld"
+ "ACK \"%!s(MISSING)\""
+ "ACTION"
+ "AFPP load is not allowed after program setup done\n"
+ "ALIGN_DOWN(pointer, CMMU::CacheLineSize()) == pointer"
+ "ALL_CPU(%!)(MISSING)"
+ "ANE in secure mode, request dropped for cacheHandler 0x%!l(MISSING)lx"
+ "ANE latency profiler already exists"
+ "ANE latency profiler created"
+ "ANE requestCallProc %!z(MISSING)u"
+ "ANE_PROPERTY_PRC Channel related logs are disabled"
+ "ANE_PROPERTY_PRC Channel related logs are enabled"
+ "ANE_PROPERTY_PRC wrong valid"
+ "Aborted network finished execution before dummy finish event created"
+ "AddScheduleInfo"
+ "AneVersionGet"
+ "AvailableScheduleInfo"
+ "BAR[%!d(MISSING)] barIndex %!d(MISSING) : bufferIndex %!d(MISSING)"
+ "Buf MSG: sapId 0x%!x(MISSING) bufNbr %!d(MISSING) subPacketSize %!d(MISSING)\n"
+ "Buf[%!d(MISSING)] sz %!l(MISSING)ld type %!d(MISSING)"
+ "BufferProcessor"
+ "CAneDebugEventsManager"
+ "CAneServer"
+ "CBufferPool::alignment != 0"
+ "CBufferPool::blockArray != 0"
+ "CBufferPool::size != 0"
+ "CBufferPool::stride != 0"
+ "CDMEDIABUSMANAGER_ENDPOINT_CMD_PING == pCmd->hdr.cmd"
+ "CDMEDIABUSMANAGER_ENDPOINT_CMD_REMAP == pCmd->hdr.cmd"
+ "CDMEDIABUSMANAGER_ENDPOINT_CMD_SEND_BUF_MSG == pCmd->hdr.cmd"
+ "CDMEDIABUSMANAGER_ENDPOINT_CMD_UNMAP == pCmd->hdr.cmd"
+ "CDMediaBusManager"
+ "CExpandablePool allocEntryIdx enter"
+ "CExpandablePool allocEntryIdx exit idx %!z(MISSING)u"
+ "CExpandablePool expandPool enter expand pool num %!d(MISSING), mCurrPoolNum %!d(MISSING) "
+ "CExpandablePool expandPool exit mCurrPoolNum %!d(MISSING)"
+ "CExpandablePool freeEntryIdx enter idx %!z(MISSING)u RefCount %!d(MISSING)"
+ "CExpandablePool freeEntryIdx exit idx %!z(MISSING)u RefCount %!d(MISSING)"
+ "CExpandablePool freeEntryIdx free poolIdx %!d(MISSING), mCurrPoolNum %!d(MISSING)"
+ "CExpandablePool maximum pool num (%!d(MISSING)) allowed already allocated"
+ "CExpandablePool retain enter idx %!z(MISSING)u RefCount %!d(MISSING)"
+ "CExpandablePool retain exit idx %!z(MISSING)u RefCount %!d(MISSING)"
+ "CFakeChannel::chDescr"
+ "CGPIOManager::Instance() != NULL"
+ "CMMULoggerPA::hisEntry != 0"
+ "CMMULoggerPA::logEntry != 0"
+ "CMMULoggerVA::hisEntry != 0"
+ "CMMULoggerVA::logEntry != 0"
+ "CMMU_LOGGER_FFW_ASSERT:%!d(MISSING) [%!z(MISSING)u] PA = 0x%!l(MISSING)x, length = 0x%!z(MISSING)x\n"
+ "CMMU_LOGGER_FFW_ASSERT:%!d(MISSING) [%!z(MISSING)u] vir = %!p(MISSING), length = 0x%!z(MISSING)x\n"
+ "CMailboxPool::Instance() != 0"
+ "CPU num: %!d(MISSING)\n"
+ "CPU_0(%!)(MISSING)"
+ "CPU_1(%!)(MISSING)"
+ "CPU_ID"
+ "CQueuePool::Instance() != 0"
+ "CRPCClient is down"
+ "CScopedLock"
+ "CSemaphorePool::Instance() != 0"
+ "CSharedMemory::Instance () != 0"
+ "CTaskPool::Instance() != 0"
+ "CTraceEventBuffer.cpp"
+ "CWorkTaskCore"
+ "CacheHandler (0x%!l(MISSING)lx) already removed from the list in the trigger ISR"
+ "CallProcedure"
+ "CallProcedure nbrOfCustomBars %!d(MISSING)"
+ "CallProcedure progId %!d(MISSING) procId %!d(MISSING) numIoBuffers %!d(MISSING)"
+ "CallProcedure progId %!d(MISSING) procId %!d(MISSING) numIoBuffers %!d(MISSING)\n"
+ "CallProcedure2"
+ "ChannelCmd"
+ "ChannelStarted"
+ "ChannelStopped"
+ "Cleanup complete. mpDataChainingStat at %!p(MISSING) deallocated"
+ "CmdAFPPLoad"
+ "CmdAFPPUnload"
+ "CmdAcknowledge"
+ "CmdCpuLoadNotification"
+ "CmdDataChainingEvent"
+ "CmdDbgEvent"
+ "CmdDsidEvent"
+ "CmdErrorNotification"
+ "CmdGetEndPointStatus"
+ "CmdGetOutstandingTicketCnt"
+ "CmdIpcEndpointSet"
+ "CmdIpcEndpointUnset"
+ "CmdIpcSharedMemoryFree"
+ "CmdIpcSharedMemoryMalloc"
+ "CmdPowerControl"
+ "CmdProcessor"
+ "CmdProgramEvent"
+ "CmdProgramSetup"
+ "CmdProgramUnsetup"
+ "CmdPropertyAccess"
+ "CmdRegSAP"
+ "CmdResetNotification"
+ "CmdSendBufMsg"
+ "CmdUnRegSAP"
+ "CpuLoadNotification"
+ "Create"
+ "Create,%!l(MISSING)u,%!s(MISSING)"
+ "Data Chaining Latency for cacheReqIdx %!d(MISSING)"
+ "DataChainingProgramEvent"
+ "DataProcessor"
+ "DbgEvent"
+ "Delete"
+ "Delete,%!l(MISSING)u,%!s(MISSING)"
+ "DeleteProgram"
+ "DepriorDsid"
+ "DirectPost"
+ "DriverCmdSanityCheck : off"
+ "DriverCmdSanityCheck : on"
+ "DriverCmdSanityCheck TD/overflow : off"
+ "DriverCmdSanityCheck TD/overflow : on"
+ "Dummy network NID %!d(MISSING) TD Complete event %!l(MISSING)ld"
+ "Dummy network for NID %!d(MISSING) TQ abort finished at %!l(MISSING)ld"
+ "DumpAFPP"
+ "EL"
+ "END"
+ "ENT: CFSM.cpp, "
+ "ENT: CScopedLock.cpp, "
+ "ENTER"
+ "EVENT_DISP options:"
+ "EXIT"
+ "EXT: CFSM.cpp, "
+ "EXT: CScopedLock.cpp, "
+ "Enable TQs after Dummy network finish in TQ[%!d(MISSING)]"
+ "Enable TQs after letting TQ[%!d(MISSING)] finish"
+ "EndPoint %!d(MISSING) sends the Ping Message\n"
+ "EndPointUnset remap not by peer %!d(MISSING)\n"
+ "EndpointCmdPing"
+ "EndpointCmdRemap"
+ "EndpointCmdSendBufMsg"
+ "EndpointCmdUnmap"
+ "Event %!d(MISSING) nbrUsrD %!d(MISSING) 22"
+ "EventProcess"
+ "FFWMSG_PAYLOAD_GET(pMsg) <= sizeof(struct ffwMsgBuffRef)"
+ "FFWMSG_PAYLOAD_GET(pMsg) <= sizeof(struct ffwMsgCmd)"
+ "FFWMSG_PAYLOAD_GET(pMsg) <= sizeof(struct ffwMsgData)"
+ "FFW_INTERPROC_BUFF_ACK_FLAG_CHECK(extra) != 0"
+ "FFW_INTERPROC_BUFF_EXCHANGE_FLAG_CHECK(param2)"
+ "FFW_OK == ffwrc"
+ "FSMSwitchNonSecure"
+ "FSMSwitchSecure"
+ "FSM_EVENT_EXELOOP_IN_SECURE"
+ "FSM_EVENT_EXELOOP_START"
+ "FSM_EVENT_EXELOOP_STOP"
+ "FSM_EVENT_EXELOOP_SWITCH_FROM_SECURE"
+ "FSM_EVENT_EXELOOP_SWITCH_TO_SECURE"
+ "FSM_STATE_EXELOOP_IDLE"
+ "FSM_STATE_EXELOOP_PAUSE"
+ "FSM_STATE_EXELOOP_RUN"
+ "FSM_STATE_EXELOOP_RUN_2_PAUSE"
+ "Failed to map command buffer"
+ "FileInfo %!s(MISSING) failed"
+ "Filewrite %!p(MISSING) %!z(MISSING)u bytes"
+ "Filewrite %!s(MISSING) %!s(MISSING)"
+ "Force Disable already set"
+ "Generic : [%!d(MISSING)] bufferIndex %!d(MISSING)"
+ "GetCacheReqEvent"
+ "GetCmdBuf"
+ "GetDirectProcCallEvent"
+ "GetLastCommittedTDInfo"
+ "GetPowerStatus"
+ "GetProcInfo"
+ "GetProgInfo"
+ "GetTraceBuffer"
+ "H11ISPInterruptMapping[(size_t)aispSource]->platformIntSrc != PLATFORM_INT_INVALID"
+ "H17TunableManager"
+ "HandleEventInt"
+ "HandleMcwInt"
+ "HandleStopTqInt"
+ "Help"
+ "IDLE"
+ "IDLE_DEFAULT"
+ "ID_GET_SOURCE(id) < INTERRUPT_SRC_TOTAL"
+ "INVALID"
+ "IOP nothing to read"
+ "IOP read done: rtPtr %!d(MISSING) wtPtr %!d(MISSING) readCount %!d(MISSING)"
+ "IOP read init: rtPtr %!d(MISSING) wtPtr %!d(MISSING) msgLen %!z(MISSING)u"
+ "IOP wait for Read"
+ "IOP write done: rtPtr %!d(MISSING) wtPtr %!d(MISSING) writeCount %!d(MISSING)"
+ "IOP write init: rtPtr %!d(MISSING) wtPtr %!d(MISSING) msgLen %!z(MISSING)u (with header)"
+ "IOP write: Message length too big"
+ "IOP write: buffer overflow"
+ "IOP write: buffer wrapup"
+ "IOP write: pBuffer not initialized yet"
+ "IOP write: register 0x%!z(MISSING)x 0x%!x(MISSING)"
+ "ISR_ID_GET_BANK(id) < lines"
+ "ISR_ID_GET_INDEX(id) < ISR_CALLBACK_MAX"
+ "ISR_ID_GET_LINE(id) < ISR_REG_ENTRY"
+ "In SendSecureModeRequest()\n"
+ "Info"
+ "InitCacheRequest"
+ "InitProcedureCallCmds"
+ "InitProcedureCallCustomBarsCmds"
+ "Initialization"
+ "InqTaskArg"
+ "Invalid log operation"
+ "IpcEndpointSet"
+ "IpcEndpointUnset"
+ "ItqIrqEnable"
+ "Kernel : bufferIndex %!d(MISSING)"
+ "KickStartCe"
+ "Load %!s(MISSING) failed"
+ "LoadProgramsInAFPP"
+ "LogEnterVerbose"
+ "MapTextSection"
+ "Master asking to release the remap while it is still being used by local user\n"
+ "NO trace buffer to post!"
+ "NULL != clockToMicroSecondConvertFunc"
+ "NULL != encode_handler[encodeScheme]"
+ "NULL != entry"
+ "NULL != instance"
+ "NULL != nbytes"
+ "NULL != pCmd"
+ "NULL != pIpcRingBufferIn[pCmd->endPointId]"
+ "NULL != pIpcRingBufferOut[pCmd->endPointId]"
+ "NULL != pMsg"
+ "NULL != pResourceIndex[endPoint]"
+ "NULL != pResourceIndex[pCmd->endPointId]"
+ "NULL != pTaskHistoryHead"
+ "NULL != physical_addr"
+ "NULL != ppReadBufferAddr"
+ "NULL != ppWriteBufferAddr"
+ "NULL != semalist"
+ "NULL != semaphore"
+ "NULL != timeCodeGetFunc"
+ "NULL != timestampFrequencyFunc"
+ "NULL != virtualAddr"
+ "NULL == instance"
+ "NULL == mpGroups[group][j].buf && STATE_RELEASED == mpGroups[group][j].state"
+ "NULL == pHandler"
+ "NULL == pIpcRingBufferIn[pCmd->endPointId]"
+ "NULL == pIpcRingBufferOut[pCmd->endPointId]"
+ "Need dummy for TQ[%!d(MISSING)]S[%!d(MISSING)], b_queue_dummy_network %!d(MISSING)"
+ "No output buffers are ready for cache request with cacheHandler 0x%!l(MISSING)lx"
+ "Notify score %!u(MISSING)\n"
+ "Oct 16 2024"
+ "Overflow detected in dram event log: programId %!d(MISSING) processId %!d(MISSING) procedureId %!d(MISSING)"
+ "POST CONDITION: "
+ "POWEROFF"
+ "POWERON"
+ "PRE CONDITION: "
+ "PROCESSING"
+ "ParseTD"
+ "PerfMode : off"
+ "PerfMode : on"
+ "Performance"
+ "Phase %!d(MISSING): %!d(MISSING)us (avg %!f(MISSING)us, std sq %!f(MISSING)us statsCount %!d(MISSING))"
+ "PiningThreadsTotal: "
+ "PostCallback"
+ "PostCmd"
+ "PowerControl"
+ "PowerDown"
+ "PowerUp"
+ "PowerUpByState"
+ "PreMapProcessStatsBuf"
+ "PrintBufDesc"
+ "PrintDescriptorProp"
+ "PrintGeneric"
+ "PrintKernelProp"
+ "PrintOperation"
+ "PrintProcedure"
+ "ProcessEndpointCmd"
+ "ProcessSubPacket"
+ "ProgramEvent"
+ "PropertyWrite"
+ "Queue dummy network using NID %!d(MISSING) Q[%!d(MISSING)]S[%!d(MISSING)] at %!l(MISSING)ld"
+ "RESET"
+ "ROUND_DOWN(paddr, CMMU::CacheLineSize()) == paddr"
+ "RPC Id is 0x%!x(MISSING)\n"
+ "RPC read file size as %!z(MISSING)u"
+ "RTK_ST_IS_SUCCESS(rc)"
+ "RTK_queue_count(queue) == tot"
+ "RTK_vm_unmap failed\n"
+ "Read %!s(MISSING) done %!z(MISSING)u bytes"
+ "ReadMessage"
+ "Received Signal %!p(MISSING)\n"
+ "Received an program whose has 0 operation : %!d(MISSING)"
+ "Received an program whose procedure has invalid operation Index : %!d(MISSING) vs %!d(MISSING)"
+ "RegisterClient"
+ "ReloadTunables"
+ "Remap :  handle 0x%!x(MISSING) : base %!p(MISSING) : len 0x%!l(MISSING)x\n"
+ "RemoveScheduleInfo"
+ "Report Debug Event : Debug Event %!d(MISSING) count %!d(MISSING) (tid:%!d(MISSING))"
+ "Reset"
+ "ReturnCacheReqEvent"
+ "ReturnDirectProcCallEvent"
+ "RunProc"
+ "RunProc2"
+ "RunProcCacheRequest"
+ "RunProcInternal"
+ "START"
+ "STOP"
+ "STREAM"
+ "STREAM_CMD_APPLY"
+ "STREAM_CMD_APPLY_NOW"
+ "STREAM_IDLE"
+ "STREAM_IDLE_DEFAULT"
+ "STREAM_INSTANDBY"
+ "STREAM_OFF"
+ "STREAM_PROCESSING"
+ "STREAM_RESET"
+ "STREAM_SETUP"
+ "STREAM_STANDBY"
+ "STREAM_START"
+ "STREAM_STOP"
+ "STREAM_TEARDOWN"
+ "SUCC"
+ "SVC"
+ "SaveProcedureCall"
+ "SaveRunToTdStop"
+ "SaveStatsBuffer"
+ "SaveToFile"
+ "Segment : bufferIndex %!d(MISSING)"
+ "SendBufMsg"
+ "SendCall"
+ "SendHWRequest"
+ "SendMsg : endPointId %!d(MISSING) sapId 0x%!x(MISSING) subPacket %!p(MISSING) subPacketSize %!d(MISSING)\n"
+ "SendSecureModeRequest"
+ "SetPMUBaseAddress"
+ "SetProgram"
+ "SetTQState"
+ "Setting high watermark to %!u(MISSING)\n"
+ "Setting low watermark to %!u(MISSING)\n"
+ "Setting poll interval to %!u(MISSING) seconds\n"
+ "Setting threshold to %!u(MISSING) ticks\n"
+ "Setup complete. mpDataChainingStat at %!p(MISSING) allocated"
+ "SetupEngineRequest"
+ "SetupExecute"
+ "Started"
+ "StatsBuf sz %!l(MISSING)ld type %!d(MISSING)"
+ "Stopped"
+ "Suspend TQs for Dummy Network"
+ "SwitchExclaveMode"
+ "TD : bufferIndex %!d(MISSING)"
+ "TQ[%!d(MISSING)] reqRunningStatus 0x%!x(MISSING)"
+ "Task"
+ "TaskArg not found"
+ "TearDownExecute"
+ "TerminateCacheRequest"
+ "TerminateProcess"
+ "Thread time"
+ "Total Abort : Raise Priority %!d(MISSING) TQ Abort %!d(MISSING)"
+ "Total Process create/terminate : %!d(MISSING)/%!d(MISSING)"
+ "Total Program add/delete       : %!d(MISSING)/%!d(MISSING)"
+ "Total Scheduled Run : %!d(MISSING) (failed %!d(MISSING))"
+ "Total finished  Run : %!d(MISSING)"
+ "TracePost2Host"
+ "TransitionProcess"
+ "Trigger input dropped: src 0x%!x(MISSING) Surface Id 0x%!x(MISSING) Offset 0x%!l(MISSING)lx"
+ "Trigger input fifo overflow. Dropped: src 0x%!x(MISSING) Surface Id 0x%!x(MISSING) Offset 0x%!l(MISSING)lx"
+ "UnMapTextSection"
+ "UnRemap :  handle 0x%!x(MISSING) : base : %!p(MISSING) len : 0x%!l(MISSING)x\n"
+ "UnsetMem : %!p(MISSING) 0x%!l(MISSING)x 0x%!x(MISSING)\n"
+ "UnsetRemap : %!p(MISSING) 0x%!l(MISSING)x 0x%!x(MISSING)\n"
+ "WriteMessage"
+ "Writer regAddr 0x%!l(MISSING)x regValue 0x%!x(MISSING)\n"
+ "[%!d(MISSING)]: intermediate spill bar id %!d(MISSING), dsid 0x%!l(MISSING)lx"
+ "[%!d(MISSING)]: prefetch bar id %!d(MISSING), dsid 0x%!l(MISSING)lx"
+ "[%!s(MISSING)]  CMD = %!x(MISSING) [%!s(MISSING)] at %!l(MISSING)ld : type = 0x%!x(MISSING) addr = %!p(MISSING), size = %!d(MISSING) \n"
+ "[%!s(MISSING)] CMD = %!x(MISSING) [%!s(MISSING)] at %!l(MISSING)ld : enable=%!d(MISSING)\n"
+ "[%!s(MISSING)] CMD = %!x(MISSING) [%!s(MISSING)] at %!l(MISSING)ld [0x%!x(MISSING)]\n"
+ "[0]: show options"
+ "[1]: TD events sorted by TID"
+ "[2]: TD events sorted by timestamp"
+ "[3]: TD performance profiling"
+ "[4]: show task switch event"
+ "[5]: network performance profiling"
+ "[ANE Exclave] Enter"
+ "[ANE Exclave] Exit"
+ "[ANE Power] down"
+ "[ANE Power] up"
+ "[AneCmd] Allocated processId %!d(MISSING) for programId %!d(MISSING) at %!l(MISSING)ld"
+ "[AneCmd] Allocated programId = %!d(MISSING) at %!l(MISSING)ld"
+ "[AneCmd] Terminated processId %!d(MISSING) for programId %!d(MISSING) at %!l(MISSING)ld"
+ "[AneCmd] Unloaded programId = %!d(MISSING) at %!l(MISSING)ld"
+ "[Desciptor prop Section] Total %!d(MISSING)"
+ "[Descriptor prop Section] X"
+ "[Generic Section] X"
+ "[Generic Section] maxAneUsed %!d(MISSING) maxNe %!d(MISSING) total Buf %!d(MISSING)"
+ "[Kernel Prop Section] Total %!d(MISSING)"
+ "[Kernel Prop Section] X"
+ "[MessageBack] cmdId %!d(MISSING) counter 0x%!x(MISSING) - %!d(MISSING)us (cache command # : %!z(MISSING)u)"
+ "[No] Generic Section"
+ "[No] Operation Section"
+ "[No] Procedure Section"
+ "[No] Segment Prop Section"
+ "[No] Segment Section"
+ "[OPERATION Section] Total %!d(MISSING)"
+ "[OPERATION Section] X"
+ "[POST] cmdId %!d(MISSING) counter 0x%!x(MISSING)"
+ "[POST] cmdId %!d(MISSING) counter 0x%!x(MISSING) => Trace # %!d(MISSING)"
+ "[PROCEDURE Section] Total %!d(MISSING)"
+ "[PROCEDURE Section] X"
+ "[TestCond] ASSERTION is set"
+ "[TestCond] Cmd_Timeout is set"
+ "[WRN] Exeloop cmd %!d(MISSING) latency %!d(MISSING)us"
+ "[X] kernelPropSection is valid but no buffer!"
+ "[X] kernelSection is valid but no buffer!"
+ "[X] verifyBAR"
+ "[X] verifyDescriptorPropSection"
+ "[X] verifyDescriptors"
+ "[X] verifyGenericSection"
+ "[X] verifyKernelPropSection"
+ "[X] verifyOperationSection"
+ "[X] verifyProcedureSection"
+ "[ipc] Send %!l(MISSING)lu"
+ "[ipc] callProc Cb %!l(MISSING)lu"
+ "[ipc] pCb %!l(MISSING)lu"
+ "_AneCallBack"
+ "_maskUnmaskMutex != (FFWMUTEX)0"
+ "actionbuf.bin"
+ "addDbgEvent"
+ "addEntry"
+ "addr != NULL"
+ "alignment != 0"
+ "allocDbgEventIdx"
+ "allocEntryIdx"
+ "allocL2SpillBufferIdx"
+ "allocatedPoolAddr[i] != NULL"
+ "array != 0"
+ "arrayEmptyBuffer != 0"
+ "array[index].ch != 0"
+ "array[index].ch == 0"
+ "array[index].inuse == false"
+ "available == tot"
+ "bGroupInUse[%!d(MISSING)] %!d(MISSING)"
+ "b_found == false"
+ "blockArray != 0"
+ "blocks <= CBuffer::idTot"
+ "bootArgs != 0"
+ "buf %!d(MISSING): addr 0x%!l(MISSING)lx size %!l(MISSING)ld"
+ "bufMsg->hdr.len <= sizeof(msg)"
+ "bufNbr <= maxAneIpcBufMsg"
+ "buffPointer"
+ "buffPool != 0"
+ "bufferLen == 0"
+ "bufferLen > sizeof(sIOPRingBuffer_t)"
+ "buffers != 0"
+ "buffers <= FFW_INTERPROC_BUFF_TOT"
+ "bundledBlocks <= CBuffer::idTot"
+ "bundledBlocksIn <= CBuffer::idTot"
+ "calcTriggerUsDelay"
+ "ch != 0"
+ "chMan != 0"
+ "chManH2T != 0"
+ "chTot <= ISP_CAMERA_CHANNEL_TOT"
+ "channel < inchannels"
+ "channelBufferSize != 0"
+ "channelPhys != 0"
+ "channelTotal != 0"
+ "channel_mem != NULL"
+ "checkBarEachAneOp"
+ "checkpointId < mMaxCheckpoints"
+ "cmdBuffer_mem != 0"
+ "cmdDataCheck"
+ "cmdInternalSema != (SEMA)0"
+ "cmdMbox != (MBOX)0"
+ "cmdMboxSema != (SEMA)0"
+ "cmdSema != (SEMA)0"
+ "cmdSynchronizationSema != (SEMA)0"
+ "context != NULL"
+ "count"
+ "create writeRingBufferLen %!d(MISSING) with writeRingBufferAddr at 0x%!l(MISSING)x %!d(MISSING)\n"
+ "createCacheRequest"
+ "curEntry"
+ "dPrio != 0"
+ "dPrio %! (MISSING)== 0"
+ "dPrio <= 124"
+ "dPrio <= RTK_THREAD_PRIORITY_MAX"
+ "dPrio >= RTK_THREAD_PRIORITY_MIN"
+ "dataBufSize == pBuf->_header._size"
+ "dataChainingRecycleOutput"
+ "dataChainingTrigger"
+ "dataChainingTriggerIsr"
+ "decPendingExeLoopCmdCnt"
+ "deferredCmdAck == false"
+ "delay trigger[%!l(MISSING)ld]: execTimestamp %!l(MISSING)ld cmdHandleTimestamp %!l(MISSING)ld"
+ "deleteCacheRequest"
+ "depriorDsid"
+ "descr.indexList != 0"
+ "descr.list != 0"
+ "descr.lock != (FFWMUTEX)0"
+ "dieRequest != (SEMA)0"
+ "dieRequest != 0"
+ "dieSema != (SEMA)0"
+ "dispDataChainingLatency"
+ "duty : %!u(MISSING) %!\(MISSING)n"
+ "enableEventLogInNetworkDesc"
+ "endPoint < maxEndpoint"
+ "endPointCb[endPoint].shareMem.nbrOfRemapItem < sCDMediaBusManagerShareMemInfo::maxSharedMemInfo"
+ "endPointCb[i].curState < ECDMEDIABUSMANGER_ENDPOINT_CB_STATE_MAX"
+ "endPointCb[pCmd->endPointId].curState != ECDMEDIABUSMANGER_ENDPOINT_CB_STATE_IDLE"
+ "endPointCb[pCmd->endPointId].curState < ECDMEDIABUSMANGER_ENDPOINT_CB_STATE_MAX"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfItem"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfItem < sCDMediaBusManagerShareMemInfo::maxSharedMemInfo"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfItem == 0"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfRemapItem"
+ "endPointCb[pCmd->endPointId].shareMem.nbrOfRemapItem == 0"
+ "endPointCb[pCmd->endPointId].shareMem.remap[i].refCount==0"
+ "endPointId < maxEndpoint"
+ "entries != 0"
+ "entries > 0"
+ "entries_per_pool > 0"
+ "entry != 0"
+ "entry != NULL"
+ "entry->callback || entry->callback_with_source"
+ "entry->stack != 0"
+ "entry->used == true"
+ "entryList != 0"
+ "entry_size > 0"
+ "exe_interval(%!)(MISSING)"
+ "execution(us)"
+ "expandPool"
+ "extra_heap_virt != NULL"
+ "ffwQueueCount (queue) == 0"
+ "ffwrc == FFW_OK"
+ "fileDescs[i].pData != nullptr"
+ "fileDescs[i].size == fileDescs[i].sizeRef"
+ "fileLen"
+ "fileWrite"
+ "filter == (class CObject *)0"
+ "fiq(us)"
+ "found"
+ "freeEntryIdx"
+ "freeL2SpillBuffIdx"
+ "freeUnusedL2SpillBufferPool"
+ "freeUnusedPool"
+ "func != 0"
+ "getActionProperty"
+ "getCacheReqPendingCmdCnt"
+ "getCacheReqState"
+ "getCacheRequestInfo"
+ "getCacheRequestIoBuffers"
+ "getCacheRequestIoBuffersNbr"
+ "getCacheRequestSignalEvents"
+ "getDataChainingInputInfo"
+ "getDirectAneRequestNetworkDesc"
+ "getFileSize"
+ "getL2SpillBufferAddr"
+ "getNbrOfTd"
+ "getProcedureCallType"
+ "getRequestId"
+ "gpTimerArray != 0"
+ "gpTimerArray[0] != 0"
+ "group < MAX_ASYNCBUFFERS_GROUPS"
+ "h"
+ "h != 0"
+ "h->ch != 0"
+ "h->chH2T != 0"
+ "h->chT2H != 0"
+ "h->managed == 0"
+ "h->signature == CFSM_SIGNATURE"
+ "h2tchIOMan != 0"
+ "handle != 0"
+ "handle != NULL"
+ "handleAbortCacheRequest"
+ "handleAbort_abortRaisePriority"
+ "handleCallProcedureWithBar"
+ "handleCmdChannel"
+ "handleDelayedTriggerCmd"
+ "handleInvalidSingleUseCacheRequest"
+ "handleIpcEndpointCmd"
+ "handlePendingCmd"
+ "handler == memHandler"
+ "handshake_info != NULL"
+ "hashNodeIdxMutex != (FFWMUTEX)0"
+ "hash_table_size > 0"
+ "head == 0"
+ "heap->addToPool(heapAddress, size) == RTK_ST_OK"
+ "heapSize != 0"
+ "heapVirt != NULL"
+ "heap_resource != (FFWMUTEX)0"
+ "heap_resource != 0"
+ "i <= 1000"
+ "id < max"
+ "id >= 0 && id < CDMEDIABUSMANAGER_CMD_COMMON_TOT"
+ "idx != 0"
+ "inUseList == 0"
+ "incPendingExeLoopCmdCnt"
+ "index < entries"
+ "index < tot"
+ "index == pEntry->parent"
+ "index >= 0"
+ "indexOfGroup < MAX_ASYNCBUFFERS_IN_GROUP"
+ "initDbgEventMem"
+ "initSharedEvents"
+ "inputPipe != 0"
+ "inputPipeEnable != nullptr"
+ "insize != CCONTROLLER_INVALID_SHARED_INSIZE"
+ "insize == sizeof(struct sCSneCmdPrintEnable)"
+ "instance != 0"
+ "instance != NULL"
+ "instance == 0"
+ "instance == NULL"
+ "instance == nullptr"
+ "instance->ch != 0"
+ "instance->chT2H != 0"
+ "internalCmdListMutex_ != (FFWMUTEX)0"
+ "interrupt(us)"
+ "interruptTimerSignal != 0"
+ "iobuf0.bin"
+ "iobuf1.bin"
+ "iobuf2.bin"
+ "irqLine != 0"
+ "isAneIdle"
+ "isCacheReqInUse"
+ "isCacheReqValid"
+ "isHWReady"
+ "isrHandle"
+ "isrhandle != 0"
+ "it"
+ "list == 0"
+ "loadMonitorTask != RTK_THREAD_NONE"
+ "lock != (FFWMUTEX) 0"
+ "lock != nullptr"
+ "log != 0"
+ "logCmdData"
+ "logDepth > 0"
+ "logEntry"
+ "logRecvCmdAck"
+ "logTot <= logDepth"
+ "mLatencyStat.maxEntryNum > 0"
+ "mLatencyStat.pCheckpoint"
+ "mLatencyStat.pLatency"
+ "mLatencyStat.pLatency[i]"
+ "mMaxCheckpoints > 0"
+ "mMutex != (RESOURCE)0"
+ "mask cmd : address = 0x%!x(MISSING), actual address = 0x%!x(MISSING)\n"
+ "mask cmd : reg addr = 0x%!x(MISSING), data = 0x%!x(MISSING)"
+ "mask cmd : size = 0x%!x(MISSING)\n"
+ "maskCount[aispSource] > 0"
+ "maxBuff != 0"
+ "max_hash_entries > 0"
+ "max_pool_num > 0 && max_pool_num <= MAX_EXPANDABLE_POOL_NUM"
+ "maxchannels != 0"
+ "maxmbox > 0"
+ "maxqueue > 1"
+ "maxres > 0"
+ "maxsema > 0"
+ "maxsig > 0"
+ "maxtask > 1"
+ "maxtimers > 0"
+ "mboxPool != 0"
+ "mboxPool == 0"
+ "memory != 0"
+ "message != NULL"
+ "messages > 0"
+ "mmu"
+ "mmuLoggerOn == true"
+ "mpEntryIdxRefCount"
+ "mpEntryIdxRefCount[idx] == 0"
+ "mpEntryIdxRefCount[idx] > 0"
+ "mpGroupBufCnt[%!d(MISSING)] %!d(MISSING)"
+ "mpGroupsOwnerName[%!d(MISSING)] %!s(MISSING)"
+ "mpPoolInfo"
+ "mpPoolInfo[mFirstUnusedPoolIdx].pIndexPool != NULL"
+ "mpPoolInfo[mFirstUnusedPoolIdx].pPoolBaseAddr == NULL"
+ "mpPoolInfo[poolIdx].pIndexPool != NULL"
+ "mpPoolInfo[poolIdx].valid != 0"
+ "msgHandler"
+ "msgLen > 0"
+ "msgPhys != 0"
+ "mutex != (FFWMUTEX) NULL"
+ "mutex != (RESOURCE) 0"
+ "myDbg"
+ "myProcCb"
+ "nBytes != NULL"
+ "name != 0"
+ "napCount == 0"
+ "nbrOfRemapLeft == endPointCb[pCmd->endPointId].shareMem.nbrOfRemapItem"
+ "newState < ECDMEDIABUSMANGER_ENDPOINT_CB_STATE_MAX"
+ "newTask != RTK_THREAD_NONE"
+ "new_end > new_start"
+ "newrdptr <= pBuf->_header._size"
+ "object != 0"
+ "object != NULL"
+ "ok == true"
+ "operationbuf.bin"
+ "outputAddr && outputSize"
+ "outputPipe != 0"
+ "outsize != 0"
+ "outstanding"
+ "outstanding <= entries"
+ "outstanding == 0"
+ "owner != 0"
+ "pAddr != NULL"
+ "pAneLatencyProfiler != __null"
+ "pBuf->_header._rdptr + sizeof(sIOPRingBufferMsgHeaderV2_t) < pBuf->_header._wrptr"
+ "pBuf->_header._rdptr + sizeof(sIOPRingBufferMsgHeader_t) < pBuf->_header._wrptr"
+ "pBufAddr && pBufSize && pBufIndex"
+ "pBufAddr[i] && pBufSize[i]"
+ "pBuffMsg->buffers <= FFW_INTERPROC_BUFF_TOT"
+ "pCmd != NULL"
+ "pCmd->bufNbr <= maxAneIpcBufMsg"
+ "pCmd->pSubPacket"
+ "pCmd->sharedMemIndex < sCDMediaBusManagerShareMemInfo::maxSharedMemInfo"
+ "pData"
+ "pEntry->parent != index"
+ "pEntry->parent < logDepth"
+ "pEntry->parent == index"
+ "pEntry->physicalAddr"
+ "pEntry->refCount"
+ "pEntry->virtualAddr"
+ "pExchange->buffers > 0"
+ "pInternalCmdArray_"
+ "pInternalCmdFreeList_"
+ "pInternalCmdList_"
+ "pItem->bufferRefCount"
+ "pItem->pBase == pCmd->sharedMemPtr"
+ "pItem->used"
+ "pMMULogger != NULL"
+ "pMMULogger == NULL"
+ "pMsg"
+ "pMsg != 0"
+ "pMyMsg->id == FFW_INTERPROC_MSG_EXCHANGE"
+ "pNodeData != NULL"
+ "pPoolAddrToFree[i] != NULL"
+ "pRingBuffer != 0"
+ "pSize != 0"
+ "pStride != 0"
+ "pSubPacket != NULL"
+ "pTemp"
+ "pTemp + pCmd->pBufSize[i] <= (size_t)pItem->pBase + pItem->memSize"
+ "pTemp >= (size_t)pItem->pBase && pTemp <= (size_t)pItem->pBase + pItem->memSize"
+ "pUserStr != 0"
+ "param1 >= sizeof(struct ffwInterProcMsg)"
+ "parent < logDepth"
+ "parent == logDepth"
+ "parent == pEntry->parent"
+ "parentEntry->child"
+ "parentEntry->physicalAddr"
+ "parentEntry->virtualAddr"
+ "parseOperation"
+ "parseProc"
+ "physicalAddr"
+ "physicalAddr != (uintptr_t) -1"
+ "pin < buffPools"
+ "pin < inputs"
+ "pin < outputs"
+ "pin < portInputs"
+ "pointer"
+ "pointer != 0"
+ "pointer != NULL"
+ "pointer == VP(messagePhys)"
+ "pool != (void *)0"
+ "pool != 0"
+ "pool == ALIGN_DOWN(pool, CMMU::CacheLineSize())"
+ "poolArray != 0"
+ "poolArray[container->attach.id] == 0"
+ "poolArray[id] != 0"
+ "poolBufferReceived != 0"
+ "poolBufferReturned != 0"
+ "poolIdx < mMaxPoolNum"
+ "poolIdx >= 0 && poolIdx < mMaxPoolNum"
+ "poolsizeIn >= CBufferPoolStatic::PoolSizeGet(buffers, newbundledBlocks, newsize, newalignment)"
+ "port < inports"
+ "powerUpAne"
+ "powerUpAneStage1"
+ "powerUpAneStage2"
+ "print"
+ "printCommandInfo"
+ "printInfo"
+ "printStats"
+ "priority != 0"
+ "priority <= RTK_THREAD_PRIORITY_MAX"
+ "priority >= RTK_THREAD_PRIORITY_MIN"
+ "processCmdOnly == true"
+ "processedCmdCounter == 0"
+ "processorEnter"
+ "processorExit"
+ "prog.tdProp.buf %!p(MISSING) procValid %!d(MISSING)"
+ "programId 0x%!x(MISSING) processId 0x%!x(MISSING) nbrAneMapping %!d(MISSING)"
+ "programId 0x%!x(MISSING) processId 0x%!x(MISSING) procedureId 0x%!x(MISSING)"
+ "propertyWrite"
+ "propertywrite 0x10A5 \x1b[32m1\x1b[39m : ANE stats"
+ "propertywrite 0x10A5 \x1b[32m2\x1b[39m : enable command detail"
+ "propertywrite 0x10A5 \x1b[32m3\x1b[39m : disable command detail"
+ "propertywrite 0x10A5 \x1b[32m4\x1b[39m : enable program info detail"
+ "propertywrite 0x10A5 \x1b[32m5\x1b[39m : disable program info detail"
+ "propertywrite 0x10A5 \x1b[32m6\x1b[39m : enable TD info detail"
+ "propertywrite 0x10A5 \x1b[32m7\x1b[39m : disable TD info detail"
+ "propertywrite 0x10A5 \x1b[32m8\x1b[39m : enable TD Header info"
+ "propertywrite 0x10A5 \x1b[32m9\x1b[39m : disable TD Header info"
+ "pushToHW"
+ "pushToHWDirect"
+ "queue != (FFWQUEUE)0"
+ "queueDepth > 1"
+ "queuePool != 0"
+ "queuePool == 0"
+ "rc != NULL"
+ "rc == 1"
+ "rc == RTK_ST_OK"
+ "rc >= 0"
+ "rdptr + sizeof(sIOPRingBufferMsgHeaderV2_t) < localCopyWrPtr"
+ "rdptr + sizeof(sIOPRingBufferMsgHeaderV2_t) < pBuf->_header._size"
+ "rdptr + sizeof(sIOPRingBufferMsgHeader_t) < localCopyWrPtr"
+ "rdptr + sizeof(sIOPRingBufferMsgHeader_t) < pBuf->_header._size"
+ "reader"
+ "recycleArray != 0"
+ "ref%!d(MISSING)/%!s(MISSING)"
+ "relocation cmd : X = 0x%!x(MISSING)\n"
+ "relocation cmd : address = 0x%!x(MISSING), actual address = 0x%!x(MISSING)\n"
+ "relocation cmd : barIdx = 0x%!x(MISSING)\n"
+ "relocation cmd : dataHi = 0x%!x(MISSING)"
+ "relocation cmd : dataLo = 0x%!x(MISSING)"
+ "relocation cmd : size = 0x%!x(MISSING)\n"
+ "reportDataChainingTriggerFailed"
+ "reportFinishEvent"
+ "reportStats"
+ "resPool != 0"
+ "resPool == 0"
+ "ret == 0"
+ "retain"
+ "retain == CBuffer::suspended"
+ "retainL2SpillBufferIdx"
+ "returnRequestId"
+ "rtkitSystemTaskList != 0"
+ "sCSneCmdProcedureCall [%!d(MISSING)] : bufferIndex %!d(MISSING)"
+ "saveToFile"
+ "sema != 0"
+ "sema != NULL"
+ "sema == 0"
+ "semaArray != (SEMA *)0"
+ "semaArray[index] != (SEMA)0"
+ "semaPool != 0"
+ "semaPool == 0"
+ "semaphore == (SEMA)0"
+ "semaphore == h->signalT2H"
+ "sequential cmd : address = 0x%!x(MISSING), actual address = 0x%!x(MISSING)\n"
+ "sequential cmd : count = 0x%!x(MISSING)\n"
+ "sequential cmd : reg addr = 0x%!x(MISSING), data = 0x%!x(MISSING)"
+ "serialPollTimer[i] != 0"
+ "serialPortPoolTimeOut[i] != (SEMA)0"
+ "serialPortSignal[i] != (SEMA)0"
+ "set buf[%!d(MISSING)] 0x%!l(MISSING)lx zero sz %!l(MISSING)ld"
+ "setAbortMode"
+ "setAbortMode %!d(MISSING)"
+ "setCustomBars"
+ "setDataChainingLatencyDisp"
+ "setDataChainingLatencyDisp %!d(MISSING)"
+ "setDirectAneRequestInfo"
+ "setEnableDynamicPowerGate"
+ "setForceDisableCacheRequest"
+ "setJobQueueId"
+ "setPerfMode"
+ "setResetMode"
+ "setResetMode %!d(MISSING)"
+ "setStartTimestamp"
+ "setTaskSwitchEventDisp"
+ "setTaskSwitchEventDisp %!d(MISSING)"
+ "setupCacheRequest"
+ "setupDirectProcCallEvents"
+ "shAddr != NULL"
+ "sharedEventsTrigger"
+ "sharedEventsTriggerIsr"
+ "sharedMem != 0"
+ "shwdStatus == 0"
+ "sigPool == 0"
+ "signal != 0"
+ "signalH2T != 0"
+ "signalResetNotification"
+ "signalSharedEvents"
+ "signalT2H != 0"
+ "size != 0"
+ "size <= sizeof(pBuffMsg->extra)"
+ "sizeInByte %! (MISSING)== 0"
+ "sizeInByte > 0"
+ "source < INT_NROF_VECTORS"
+ "source < ISR_REG_ENTRY"
+ "source < lines * ISR_REG_ENTRY"
+ "source >= 0"
+ "src != NULL"
+ "stacksize != 0"
+ "startInvalidateCacheRequestInExeLoop"
+ "started == false"
+ "statsBufferSizeGet"
+ "status == FFW_OK"
+ "status == RTK_ST_OK"
+ "super::Available() == (int)super::Managed()"
+ "switchToIsolatedMode"
+ "syncCmdMutex_ != (FFWMUTEX)0"
+ "synchronization != (SEMA)0"
+ "synchronize != (SEMA)0"
+ "task != (TASK)0"
+ "task != 0"
+ "taskId == self"
+ "taskPool == 0"
+ "taskTime != 0"
+ "td size %!z(MISSING)u while usedSize %!d(MISSING)"
+ "temp != 0"
+ "this->buffers >= buffers"
+ "threadHistoryLock != (FFWMUTEX) 0"
+ "ticket < cmdDepth"
+ "timerHandle != NULL"
+ "timerSem != NULL"
+ "token != 0"
+ "tot != 0"
+ "tot == 0"
+ "tot > 0"
+ "totalElapsed %!l(MISSING)ld or totalElapsedInterval %!l(MISSING)ld is invalid value\n"
+ "totalElapsed(from tracekit) %!l(MISSING)ld, totalElapsedDuringCheckpoint %!l(MISSING)ld\n"
+ "totalElapsedInterval(from tracekit) %!l(MISSING)ld, totalElapsedIntervalDuringCheckpoint %!l(MISSING)ld\n"
+ "tree_resource != (FFWMUTEX)0"
+ "tree_resource != 0"
+ "unknown TD command type 0x%!x(MISSING)"
+ "updateAndEnqueueOneSegment"
+ "updateDefSetting"
+ "updateEngineRequestSegment"
+ "updateStatsBufferData"
+ "vPrintLock != (SEMA)0"
+ "vPrintLock == (SEMA)NULL"
+ "value != NULL"
+ "verifyBAR"
+ "verifyCustomBar"
+ "verifyDescriptorPropSection"
+ "verifyDescriptors"
+ "verifyGenericSection"
+ "verifyKernelPropSection"
+ "verifyOperationSection"
+ "verifyProcedure"
+ "verifyProcedureSection"
+ "verifyProgram"
+ "virtualAddr"
+ "virtualAddr != NULL"
+ "waitTQIdle"
+ "wiringPageSize == 0x4000"
+ "write to overwrite ref%!d(MISSING)/%!s(MISSING)"
+ "~CScopedLock"
- "!a64e"
- "%!s(MISSING) .Sanity check failure!\n"
- "22:52:29"
- "Couldn't find ShareMemInfoItem to free !!!\n"
- "IPC Endpoint cmd failed %!d(MISSING)"
- "IPC Endpoint cmd failure"
- "Run out of CSharedMemory !!!\n"
- "Sep 28 2024"
- "pProc != __null"
- "pProg != __null"
- "unremap WriteMessage failed\n"

```
